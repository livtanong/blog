#+hugo_base_dir: ../
#+hugo_auto_set_lastmod: t

#+seq_todo: TODO DRAFT DONE

#+property: header-args :eval never-export

#+author: Levi Tan Ong

* DRAFT Airtable Expense Logging with Ledger Mode
:PROPERTIES:
:EXPORT_FILE_NAME: expense-logging-with-ledger-mode-and-airtable
:EXPORT_DATE: 2019-3-31
:END:
** Summary

Many companies and organizations subsidize certain things like transit, food,
and lodging for their employees, with the requirement that the latter log these
expenses via some system defined by the Powers That Be. My company uses
[[https://airtable.com][Airtable]]. [fn:airtable]

If you use [[https://www.ledger-cli.org/][Ledger]] to maintain your personal accounting, it can and will be
tedious to log your subsidized/reimbursable expenses on both Ledger /and/
Airtable. Despite the inconvenience, this data is valuable to you, and you
should keep track of it to better understand your lifestyle.

Luckily for us, Airtable has an API. This article details my efforts in building
a set of emacs functions for posting expenses from a Ledger file onto Airtable.
Because I want this article to be as accessible and as informative as possible,
I will go through the derivation of this script including exploring
ledger-mode's implementation.

** Ledger

*** A Typical Receipt

Let's say that earlier in the day, you needed to gas up, so you passed by
Richard Stallman's Gas Station. It just so happens that the Philippine Peso
(PHP), despite all odds, has become the dominant currency of the United States.
The acronym is no longer associated with PHP: Hypertext Processor, and the
latter is now nothing more than a bad memory.

#+NAME: Gas Receipt
#+BEGIN_SRC ledger :results silent
2019/03/29 Richard Stallman's Gas Station
    expenses:transport:fuel                     2000 PHP
    expenses:food                                200 PHP
    assets:cash                                -2200 PHP
#+END_SRC

You also spent 200 PHP on food, because it was there, just begging to be bought,
and human nature doesn't change much between parallel realities. In ledger
terms, we call the snippet above an ~xact~ as a whole, rather than a
transaction. To avoid confusion, we'll have to define a bunch of terms.

*** Definition of Terms

**** payee
A contextualizing description of the xact. Could be just as simple as "John", or
"McDonald's", but sometimes it's more detailed, like "Martine, for that gallon
of couscous."

**** account
A "bucket" of money. In Ledger, accounts can have a sort of tree structure where
"Tags" of increasing specificity are joined together by colons to give more
context. e.g. ~expenses:transport:fuel~, ~assets:cash~, ~assets:savings:php~

**** transaction
A line item detailing a change in the amount stored in an ~account~. The
~account~ is separated from the amount by at least two spaces. Referred to in
the Ledger source as ~acct-transaction~. For example:
#+begin_src ledger
expenses:transport:fuel  2000 PHP
#+end_src
You can say that an ~xact~ is a group of ~transactions~ contextualized by a date
and a ~payee~.

*** Utility
Before we start tinkering, we have to first realize that since we're using
org-mode and babel, we can execute whatever code we write. We're referring to
that gas receipt above, so we need to find some way to easily refer to various
parts of that receipt easily. ~org-babel-goto-named-src-block~ exists.

#+begin_src emacs-lisp :exports both :results pp
(save-excursion
  (org-babel-goto-named-src-block "Gas Receipt")
  (org-element-at-point))
#+end_src

#+RESULTS:
: (src-block
:  (:language "ledger" :switches nil :parameters ":results silent" :begin 1643 :end 1922 :number-lines nil :preserve-indent nil :retain-labels t :use-labels t :label-fmt nil :value "2019/03/29 Richard Stallman's Gas Station\n    expenses:transport:fuel                     2000 PHP\n    expenses:food                                200 PHP\n    assets:cash                                -2200 PHP\n" :post-blank 1 :post-affiliated 1663 :name "Gas Receipt" :parent nil))

Yup, that looks right. If we go down one row, we should get both the date and
payee.

#+begin_src emacs-lisp :exports both :results pp
(save-excursion
  (org-babel-goto-named-src-block "Gas Receipt")
  (next-line)
  (thing-at-point 'line t))
#+end_src

#+RESULTS:
: "2019/03/29 Richard Stallman's Gas Station\n"

Booyeah. Let's wrap this all up into a function.

#+begin_src emacs-lisp :results silent
(defun goto-gas-receipt (line-offset)
  (org-babel-goto-named-src-block "Gas Receipt")
  (next-line line-offset))
#+end_src

Let's test it.

#+begin_src emacs-lisp :exports both :results pp
(save-excursion
  (goto-gas-receipt 2)
  (thing-at-point 'line t))
#+end_src

#+RESULTS:
: "    expenses:transport:fuel                     2000 PHP\n"

We're ready!

*** The Payee

Let's rummage through the ledger [[https://github.com/ledger/ledger-mode][source]] to see if we can find a good starting
point. It turns out that [[https://github.com/ledger/ledger-mode/blob/c59bbfcc3274d113dec68121786546979f33dad0/ledger-xact.el#L65][ledger-xact-payee]] exists. Since ~ledger-xact-payee~
uses ~point~, and I want to evaluate things using ~org-babel-execute-src-block~,
we'll have to take an excursion to position ~1287~ (Found by placing my cursor
on some character that I want, and calling ~(point)~) before invoking ~ledger-xact-payee~.

#+begin_src emacs-lisp :exports both
(save-excursion
  (goto-gas-receipt 1)
  (ledger-xact-payee))
#+end_src

#+RESULTS:
: Richard Stallman's Gas Station

Great, it works as advertized. We also want to figure out the date and the
amount, so let's see how ~ledger-xact-payee~ found the payee.

#+begin_src emacs-lisp :exports code :results silent
(defun ledger-xact-payee ()
  "Return the payee of the transaction containing point or nil."
  (let ((i 0)) ;; (1)
    (while (eq (ledger-context-line-type
                (ledger-context-other-line i))
               'acct-transaction)
      (setq i (- i 1))) ;; (2)
    (let ((context-info (ledger-context-other-line i)))
      (if (eq (ledger-context-line-type context-info) 'xact) ;; (3)
          (ledger-context-field-value context-info 'payee) ;; (4)
        nil))))
#+end_src

So it looks like:
1. We start from point
2. Move up a line if we're in an account transaction
3. If the line is the ~xact~
4. Return the ~payee~. Simple enough!

*** The Date

Unfortunately, I haven't found anything like ~ledger-xact-date~,
so we'll have to build our own. Since the implementation would be too similar to
~ledger-xact-payee~, I think it would be worth refactoring ~ledger-xact-payee~
into something more general and composable.

#+begin_src emacs-lisp :results silent
(defun ledger-xact-context
  "Return the context of the transaction containing point or nil."
  (let ((i 0))
    (while (eq (ledger-context-line-type
                (ledger-context-other-line i))
               'acct-transaction)
      (setq i (- i 1)))
    (let ((context-info (ledger-context-other-line i)))
      (if (eq (ledger-context-line-type context-info) 'xact)
          context-info
        nil))))

(defun ledger-xact-payee ()
  "Return the payee of the transaction containing point or nil."
  (let ((xact-context (ledger-xact-context)))
    (if xact-context
        (ledger-context-field-value xact-context 'payee)
      nil)))
#+end_src

This way, we can just use ~ledger-context-field-value~ to get the date or payee.
I have, in fact, submitted a [[https://github.com/ledger/ledger-mode/pull/168][PR]] to ledger-mode. I hope it will be accepted!

#+begin_src emacs-lisp :exports both :results code
(save-excursion
  (goto-gas-receipt 1)
  (let ((xact-context (ledger-xact-context)))
    (list (ledger-context-field-value xact-context 'date)
          (ledger-context-field-value xact-context 'payee))))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
("2019/03/29" "Richard Stallman's Gas Station")
#+end_src

*** The Amount

There are always at least two amounts in every ~xact~ because of double-entry
bookkeeping. Because ledger entries can get more complicated than this, we can't
just assume the simplest case. Instead, we can just /not/ assume! We will let
the user specify it for us. We don't need to travel past our point, which means
we can use ~(ledger-context-at-point)~.

#+begin_src emacs-lisp :exports both :results code
(save-excursion
  (goto-gas-receipt 4)
  (let ((point-context (ledger-context-at-point)))
    (ledger-context-field-value point-context 'commoditized-amount))
  )
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
"-2200 PHP"
#+end_src

Let's look at another transaction.

#+begin_src emacs-lisp :exports both :results code
(save-excursion
  (goto-gas-receipt 3)
  (let ((point-context (ledger-context-at-point)))
    (ledger-context-field-value point-context 'commoditized-amount)))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
"200 PHP"
#+end_src

*** Convenience

We now have everything we need to create a function that can return all the data
we need in a convenient form.

#+begin_src emacs-lisp :exports both :results code
(defun airtable--expense-data ()
  "Return transaction data for submitting an expense report."
  (let ((xact-context (ledger-xact-context))
        (point-context (ledger-context-at-point)))
    (if (and xact-context
             (eq (ledger-context-line-type point-context) 'acct-transaction)
             (ledger-context-field-present-p point-context 'commoditized-amount))
        (let ((tx-data (list))
              (date (ledger-context-field-value xact-context 'date))
              (payee (ledger-context-field-value xact-context 'payee))
              (amount (ledger-context-field-value point-context 'commoditized-amount)))
          (map-put tx-data 'date date)
          (map-put tx-data 'payee payee)
          (map-put tx-data 'amount amount)
          tx-data)
      nil)))

(save-excursion
  (goto-gas-receipt 4)
  (airtable--expense-data)
  )
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
((amount . "-2200 PHP")
 (payee . "Richard Stallman's Gas Station")
 (date . "2019/03/29"))
#+end_src

Now we have a nice, convenient associative data structure containing everything
we need for the next part.


** Airtable

*** Setup

This section is tricky, because this involves secrets: the "project id" included
in the URL, and the API key. Mine are... just kidding. Let's load the encrypted
secrets.

#+begin_src emacs-lisp :exports code :results silent
(load-file "../secrets/airtable-secrets.el")
(require 'airtable-secrets)
#+end_src

We'll need the excellent [[https://github.com/tkf/emacs-request][emacs-request]] library.

#+begin_src emacs-lisp :results silent
(use-package request :ensure t)
#+end_src

Each Airtable *base* has its own tables and schema, so it will be up you to
figure out the right table to interact with, and exact fields to use in the JSON
payload. Let's created a blank airtable base from the [[https://airtable.com/templates/hr-and-recruiting/expAJmFL8SkCqfjnj/expense-tracking][expense tracking template]].
We can figure out the api for this particular base by going to
https://airtable.com/api and selecting the base we just made.

*** Experimentation

I'm wary about running POST requests right off the bat without being sure about
our requests. We'll use ~request.el~ for our http needs. Let's try to get the
list of receipts, and since we're only doing this for confirmation, we can set
(1) ~maxRecords~ to 1. We need to make the request synchronous (2) so that org
mode can capture the returned value.

#+begin_src emacs-lisp :async :exports both :results value code
(request-response-data
 (request airtable-secrets-url
          :type "GET"
          :params '(("maxRecords" . 1) ;; (1)
                    ("view" . "Main View"))
          :sync t ;; (2)
          :parser 'json-read
          :headers `(("Content-Type" . "application/json")
                     ("Authorization" . ,(format "Bearer %s" airtable-secrets-auth-token)))))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
((records .
          [((id . "recvM8nBwdDtki4vo")
            (fields
             (Receipt\ Photo .
                             [((id . "attRl2O8I67NQBQXo")
                               (url . "https://dl.airtable.com/0cWfA9hiTOWP5QfdUNij_cactuscastle.jpg")
                               (filename . "cactuscastle.jpg")
                               (size . 16064)
                               (type . "image/jpeg")
                               (thumbnails
                                (small
                                 (url . "https://dl.airtable.com/MBqpodIaQJWI62Q5t1iq_cactuscastle.jpg")
                                 (width . 48)
                                 (height . 36))
                                (large
                                 (url . "https://dl.airtable.com/WQVXLIuiQTGYIgDoAIxY_cactuscastle.jpg")
                                 (width . 256)
                                 (height . 191))))])
             (Category . "Interior Decor")
             (Short\ Description . "Cactus")
             (Total . 11.5)
             (Date\ &\ Time . "2015-11-06T14:22:00.000Z")
             (Notes . "A cute blue cactus with golden spines, will go great in the dining room.")
             (Who\ Paid\? . "Maritza"))
            (createdTime . "2015-08-03T23:10:03.000Z"))]))
#+end_src

Great, we got a response! Now let's try to POST a new entry. We're setting the
payor as "Quinns" because that's one of two values allowed by the template.

#+begin_src emacs-lisp :async :exports both :results value code
(request-response-data
 (request airtable-secrets-url
          :type "POST"
          :sync t
          :parser 'json-read
          :data (json-encode `(("fields" . (("Short Description" . "Testing")
                                            ("Who Paid?" . "Quinns") ;; (1)
                                            ("Date & Time" . "2019-04-09T14:22:00.000Z")
                                            ("Total" . 10)
                                            ))))
          :headers `(("Content-Type" . "application/json")
                     ("Authorization" . ,(format "Bearer %s" airtable-secrets-auth-token)))
          ))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
((id . "recFyrCYKAAwjELUr")
 (fields
  (Short\ Description . "Testing")
  (Total . 10)
  (Date\ &\ Time . "2019-04-09T14:22:00.000Z")
  (Who\ Paid\? . "Quinns"))
 (createdTime . "2019-04-09T11:25:12.000Z"))
#+end_src

We can now create a command to post expenses!

#+begin_src emacs-lisp :async :exports both :results output
(defun airtable--post-expense ()
  "derp"
  (interactive)
  (let* ((xact-data (airtable--expense-data))
         (xact-date (cdr (assoc 'date xact-data)))
         (xact-amount (cdr (assoc 'amount xact-data)))
         (xact-payee (cdr (assoc 'payee xact-data)))
         (amount (abs (string-to-number (car (split-string xact-amount)))))
         (date (format "%sT12:00:00.000Z"
                       (replace-regexp-in-string (regexp-quote "/") "-" xact-date))))
    (request airtable-secrets-url
             :type "POST"
             :sync t
             :parser 'json-read
             :data (json-encode `(("fields" . (("Short Description" . ,xact-payee)
                                               ("Who Paid?" . "Quinns")
                                               ("Date & Time" . ,date)
                                               ("Total" . ,amount)
                                               ))))
             :headers `(("Content-Type" . "application/json")
                        ("Authorization" . ,(format "Bearer %s" airtable-secrets-auth-token)))
             :success (cl-function
                       (lambda (&key data &allow-other-keys)
                         (print "Expense Posted!")))
             :error (cl-function
                     (lambda (&key error-thrown &allow-other-keys)
                       (print error-thrown))))))

(save-excursion
  (goto-gas-receipt 4)
  (airtable--post-expense)
  )
#+end_src

#+RESULTS:
:
: "Expense Posted!"

A quick trip to Airtable tells me that indeed, the entry has been posted. Now
all I have to do is take a picture, and the Airtable mobile app makes that easy.

** Footnotes
[fn:airtable] My company also uses Airtable for other administrative tasks like
tracking leaves of absence and many other things. We've mostly switched over to
[[https://www.notion.so][Notion]] because it performs better as a knowledge base, but unfortnately Notion
doesn't have an API.



* TODO Github READMEs in Org Mode
:PROPERTIES:
:EXPORT_FILE_NAME: github-readmes-in-org-mode
:EXPORT_DATE: 2019-3-31
:END:
** clojars image links
https://github.com/wallyqs/org-ruby/issues/42
** code block evaluation
*** results being funky
https://orgmode.org/manual/results.html
*** multiline headers for readability
https://orgmode.org/manual/Using-Header-Arguments.html
*** results not showing on github
https://github.com/wallyqs/org-ruby/issues/62
* TODO Fish et al
:PROPERTIES:
:EXPORT_FILE_NAME: fish-et-al
:EXPORT_DATE: 2019-3-31
:END:
** clojars and credentials
** git crypt

* Footnotes
* COMMENT Local Variables                          :ARCHIVE:
# Local Variables:
# eval: (org-hugo-auto-export-mode)
# End:
